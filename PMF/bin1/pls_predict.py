'''
#=============================================================================
#     FileName: pls_predict.py
#         Desc: 
#       Author: jlpeng
#        Email: jlpeng1201@gmail.com
#     HomePage: 
#      Created: 2014-08-21 19:29:51
#   LastChange: 2014-08-22 13:12:45
#      History:
#=============================================================================
'''
import sys
import pickle
from getopt import getopt
import numpy as np
try:
    from sklearn.cross_decomposition import PLSRegression
except ImportError:
    from sklearn.pls import PLSRegression


def main(argv=sys.argv):
    if len(argv) not in (6,8):
        print "\nOBJ: PLS.predict(N_ij(r))"
        print "\nUsage:"
        print "  %s [options] output"%argv[0]
        print "\n[options]"
        print "  --nijr  file: generated by get_nijr.py"
        print "  --model file: generated by pls_train.py"
        print "  --tey   file: each line should be `name actualY`"
        print "                if given, RMSE, MAE, and r will be calculated"
        print ""
        sys.exit(1)

    #parse options
    options,args = getopt(argv[1:], '', ['nijr=','model=','tey='])
    nijr_file = None
    model_file = None
    y_file = None
    output_file = None
    for opt,val in options:
        if opt == '--nijr':
            nijr_file = val
        elif opt == '--model':
            model_file = val
        elif opt == '--tey':
            y_file = val
        else:
            print "Error: invalid option",opt
            sys.exit(1)
    assert (nijr_file is not None) and (model_file is not None)
    assert len(args) == 1
    output_file = args[0]


    #read nij and construct testX
    #each item `i,j,n`  ==> testX[][j*len(DC_TYPES)+i] = n
    inf = open(nijr_file,'r')
    line = inf.readline()
    num_DC_TYPES = int(line.split(',')[0].split('=')[-1])
    num_bins = int(line.split('=')[-1])
    test_list = []
    testX = []
    #testX = np.zeros((len(test_list), num_DC_TYPES*num_bins))
    for line in inf:
        if line.startswith('#'):
            continue
        testX.append([0]*(num_DC_TYPES*num_bins))
        line = line.split()
        test_list.append(line[0])
        for item in line[1:]:
            i,j,n = map(int, item.split(','))
            index = j*num_DC_TYPES+i
            testX[-1][index] = n
    inf.close()
    testX = np.asarray(testX)
    print "testX.shape:",testX.shape

    #load PLS model and do prediction
    inf = open(model_file,'r')
    pls1 = pickle.load(inf)
    inf.close()
    predY = pls1.predict(testX)
    predY = np.ndarray.flatten(predY)
    
    if y_file is not None:
        #to read actual y-values
        inf = open(y_file,'r')
        actualY = np.zeros(len(test_list))
        count = 0
        for line in inf:
            if line.startswith("#"):
                continue
            name,val = line.split()
            try:
                i = test_list.index(name)
                actualY[i] = float(val)
                count += 1
            except ValueError:
                print name," from",y_file,"is not in",nijr_file
                sys.exit(1)
        if count != len(test_list):
            print >>sys.stderr, "Error: number(%d) of actualY read is not equal to the number of testing samples(%d) in %s"%(count, len(test_list), nijr_file)
            sys.exit(1)
        inf.close()
        mae = calcMAE(actualY, predY)
        rmse = calcRMSE(actualY, predY)
        r = calcR(actualY, predY)
        outf = open(output_file,'w')
        print >>outf, "name actualY predictY"
        for i in xrange(len(test_list)):
            print >>outf, test_list[i],actualY[i],predY[i]
        outf.close()
        print "\n  statistics on test set"
        print "  RMSE=%g, MAE=%g, r=%g\n"%(rmse, mae, r)
    else:
        outf = open(output_file,'w')
        print >>outf, "name predictY"
        for i in xrange(len(test_list)):
            print >>outf, test_list[i],predY[i]
        outf.close()


calcMAE = lambda actualY, predictY: np.mean(np.abs(actualY-predictY))
calcRMSE = lambda actualY, predictY: np.sqrt(np.mean(np.power(actualY-predictY,2)))
calcR = lambda actualY, predictY: np.corrcoef(actualY, predictY)[0][1]


main()

